# 一、初识引用
赋值其实就是对内存中的数据进行一次拷贝，如果是简单的数据类型（char,int,float等）这个赋值过程会很快，但是如果是复杂数据（对象，数组，结构体等），这个过程就可能消耗很多时间，效率很低。所以，C++在函数调用时，禁止传递数组的内容，而是传递数组指针。而对对象和结构体没有限制，但是建议使用结构体指针，那样更快一点。最后是对象，C++中提供一种比指针更便捷的传递聚合类数据的方式：引用。

引用可以看作是数据的别名，类似windows中的快捷方式，语法：type &name = data。type是被引用的数据类型，name是引用的名称，data被引用的数据。先看一个例子：
```c++
#include <iostream>
#include <string>
using namespace std;

int main(){
    int a = 99;
    int &r = a;
    cout << a << ", " << r << endl;    // 99, 99
    cout << &a << ", " << &r << endl;  // 0x61fe14, 0x61fe14
    r = 40;   // or r = 40
    cout << a << ", " << r << endl;    // 40, 40
    return 0; 
}
```
1. 引用必须在定义的时候同时初始化，而且一个引用必须从一而终，不能再引用其他数据，有点类似常量；
2. 引用再定义的时候加&，在使用的时候不能加&，加&表示取地址；
3. 引用之后如果修改引用或者被引用数据，那么两者都会改变；
4. 如果不希望引用后改变元原始数据，可以在引用定义时加const限制：const type &name = value;

## 1.1、引用作为参数传参
定义或者声明函数时，可以将函数的形参指定为引用的形式，这样调用函数时就可以将实参和形参绑定在一起，让他们指向同一份数据，如果在函数中改变了形参的数据，那么实参的数据也会被修改。
看下下面这个经典案例：
```c++
#include <iostream>
#include <string>
using namespace std;
// 直接传递参数内容
void swap1(int a, int b){
    int temp = a;
    a = b;
    b = temp;
}
// 传递指针
void swap2(int *p1, int *p2){
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
// 传递引用
void swap3(int &r1, int &r2){
    int temp = r1;
    r1 = r2;
    r2 = temp;
}

int main(){
    int num1 = 1, num2 = 2;
    swap1(num1, num2);
    cout << num1 << " " << num2 << endl;  // 1 2
    num1 = 1, num2 = 2;
    swap2(&num1, &num2);
    cout << num1 << " " << num2 << endl;  // 2 1
    num1 = 1, num2 = 2;
    swap3(num1, num2);
    cout << num1 << " " << num2 << endl;  // 2 1
    return 0;
}
```
1. swap1直接传递参数内容，在swap中改变的是形参的内容，但是形参和实参是独立的，形参内容并不影响实参，所有看到输出num1和num2是不变的；
2. swap2调用指针，调用的时候是将num1和num2的地址传递给p1,p2，这样p1，p2就指向a，b所代表的数据，通过修改指针直接就修改了实参的值；
3. swap3传递的是引用，调用的时候会直接将r1绑定到num1所指向的数据，r2绑定到num2所指向的数据，这时候r1和num1、r2和num2其实就代表的是一份数据，只是名字不一样而已，所以修改形参相当于直接就修改了实参；

## 1.2、引用作为函数返回值
```c++
#include <iostream>
#include <string>
using namespace std;
int &plus(int &r){
	r += 10;
	return r;
}
int main(){
	int num1 = 10;
	int num2 = plus(num1);
	
	cout << num1 << " " << num2 << endl;   // 20 20
}
```
但是要注意：返回的时候不能返回局部数据，因为当函数用完后局部数据被销毁，下次使用时数据就不存在了。

# 二、引用的本质
引用是对指针的简单封装，底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度是一样的，32位里占用4字节，64位里占用8字节。引用的好处是让代码更简洁，更方便。

引用就是指针。对编译器来说，指针和引用是一个东西。指针和引用的区别，其实只是C++语法层面上的区别。

指针和引用的区别：
1. 初始化区别：指针在声明的时候允许不对指针进行初始化赋值，允许野指针存在；而引用在声明的时候必须进行初始化赋值；
2. 重新赋值的区别：指针是允许再次赋值的，比如指针先指向a,再指向b，这样a和b的值是不会变的；而引用如果再次赋值，a的值会变为b的值，引用&r=a，这里的r其实就是a，如果再&r=b，相当于就是a=b，所以a的值会改变的；
3. 指针自增++操作，表示指向下一个地址，引用自增++操作表示引用的值+1；
4. 指针可以多级，但是引用只能一级；
   
# 三、初识指针
指针就是指针变量，存放的是变量在内存中的**起始地址**。32位里占用4字节，64位里占用8字节，sizeof()函数可以查看。

指针声明语法：数据类型 *变量名a; 
指针赋值语法：数据类型 *变量名a = &变量名b; 一般我们将指针的名字命名为 *p变量名 用于区分普通变量。

在指针前面加*，对指针进行解引用，也可以得到变量的值：
```c++
#include <iostream>
#include <string>
using namespace std;
int main(){
	int a = 3;
    int *p = &a;
    cout << "a=" << a << endl;     // a=3
    cout << "*p=" << *p << endl;   // *p=3

    *p = 8;                        // 这句话等价于a=8
    cout << "a=" << a << endl;     // a=8 
    cout << "*p=" << *p << endl;   // *p=8
    return 0;
}
```
**&a和p：都是表示a的地址；a和*p：都是表示a的值**。

## 3.1、指针用于参数传参
如果把函数的形参声明为指针，调用的时候把实参的地址传进去，那么形参存放的就是实参的地址，在函数中通过解引用就可以直接操作实参的数据，甚至可以修改实参的值，这种方法称为地址传递。

形参是普通变量称为值传递。在函数中修改形参并不会修改实参的值。

传地址的意义：
1. 可以在函数中修改实参的值；
2. 减少内存拷贝，提升性能，因为普通的值传递，内存还需要为形参分配空间，但是如果是地址传递，内存不需要为形参再分配空间；

## 3.2、用const修饰指针
用const修饰普通变量，这个变量就变成了常量。

const修饰指针的方法有三种：
1. 常量指针（实际开发中用的最多）：const 数据类型 *变量名；不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）
   
   不过指针指向的变量(对象)可以改变（原先指向a,现在可以指向b）
    ```c++
    #include <iostream>
    using namespace std;
    int main(){
        int a = 5;
        const int *p = &a;
        *p = 20;      // assignment of read-only location '* p'   不能通过解引用修改指针指向地址的值
        return 0
    ```
    一般用于修饰函数中的某些形参，表示不希望再函数中修改这个实参地址中的值；
2. 指针常量：数据类型 *const 变量名 ；指向的变量（对象）不可以改变；所以在定义的时候必须初始化，否则没有意义；它可以通过解引用的方法修改内存地址中的值：
    ```c++
    #include <iostream>
    using namespace std;
    int main(){
        int a = 5;
        int *const p = &a;
        // *p = 20;    // 可以修改指针所指向的变量的值
        int b = 20;
        p = &b;      // 不能指向别的变量 
    }
    ```
    开发当作基本不怎么使用它，但是C++中把指针常量做了特殊的处理，在C++中有一个新的名字，叫引用。
3. 常指针常量：const 数据类型 *const 变量名; 指针指向的对象不可改变，也不能通过解引用的方法修改内存地址中的值；
    在实际开发中也几乎不用，不过它还有个其他的名字：常引用。

## 3.3、void关键字
1. 函数开头用void，表示函数没有返回值；
2. 函数参数填void，表示函数不需要参数=括号中什么也不写；
3. 函数的形参用void*,表示接受任意数据类型的指针，这个用的比较多，很多C和C++库函数都用的void*,可以增加代码的鲁棒性；
   不能用void指针什么变量，它不能代表一个真实的变量；
   不能对void指针直接使用解引用，需要将它先转换为其他类型的指针；
   把其他指针赋值给void指针不需要转换；
   把void指针赋值给其他类型的指针需要转换；

## 3.4、待更新
https://www.bilibili.com/video/BV16T4y1w7wm?p=6&vd_source=5f6bbc1038b075757cb446f800f3cd56